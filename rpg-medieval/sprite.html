<!DOCTYPE html>  <html lang="es">    <head>    
<meta charset="UTF-8">    
<title>RPG Medieval 2D</title>    
<style>    
body{    
    margin:0;    
    background:#111;    
    display:flex;    
    justify-content:center;    
    align-items:center;    
    height:100vh;    
}    
canvas{    
    background:linear-gradient(#6ec6ff,#b3e5fc);    
    image-rendering:pixelated;    
}  #pauseBtn{  
position: absolute;  
top: 15px;  
right: 15px;  
padding: 8px 14px;  
font-size: 16px;  
cursor: pointer;  
z-index: 10;  
}  
</style>  </head>  <body>    
<canvas id="game" width="1000" height="500"></canvas>  <button id="pauseBtn"    
style="position: fixed;    
top: 10px;    
right: 10px;    
padding: 10px 18px;    
font-size: 16px;    
cursor: pointer;    
z-index: 10;    
">  
‚è∏Ô∏è Pausa  
</button>  <button id="respawnBtn" style="    
position: fixed;    
top: 60%;    
left: 50%;    
transform: translate(-50%,-50%);    
padding: 16px 30px;    
font-size: 22px;    
display: none;    
z-index: 20;    
cursor: pointer;    
">
Respawn
</button>

<script>    
const canvas = document.getElementById("game");    
const ctx = canvas.getContext("2d");    
    
const GRAVITY = 0.6;    
const GROUND_Y = canvas.height - 190;    
const FRAME_SIZE = 128;    
const GAME_SCALE = 1.5;    
    
let gamePaused = false;    
let deathTimer = 0;    
let playerDead = false;
let gameOver = false;

let currentEvolution = 1;

let evolving = false;
let evolveTimer = 0;
const EVOLVE_TIME = 60;


function gainExp(amount){
    player.exp += amount;

    if(player.exp >= player.nextLevelExp){
        player.exp -= player.nextLevelExp;
        player.level ++;
        player.nextLevelExp = Math.floor(player.nextLevelExp * 1.4);

        console.log("SUBISTE A NIVEL", player.level);

        onLevelUp();

        if(player.level === 6 && currentEvolution === 1){
            evolveTo2();
        }
    }
}

function onLevelUp(){
    player.maxHp += 20;
    player.hp = player.maxHp;
    player.speed += 0.3;

}
function evolveTo2(){
    evolving = true;
    evolveTimer = 120;
}

function finishEvolutionTo2(){
    currentEvolution = 2;

    player.maxHp += 30;
    player.hp = player.maxHp;
    player.speed += 0.5;
    player.damage += 5;
    reloadPlayerSprites();
    evolving = false;
    gamePaused = false;


    console.log("EVOLUCION√ìN 2 ACTIVADA");
}

function getPlayerSpritePath() {
    return `Sprites/Knight/evo${currentEvolution}/`;
}



    
    
// =======================    
// SPRITES PLAYER    
// =======================    
const playerSprites = {    
 idle:{ file:"Idle.png", img:new Image(), frames:6},
 run:{ file:"Run.png", img:new Image(), frames:8},    
 jump:{ file:"Jump.png", img:new Image(), frames:10},    
 attack1:{ file:"Attack_1.png",img:new Image(), frames:4},    
 attack2:{ file:"Attack_2.png", img:new Image(), frames:3},    
 attack3:{ file:"Attack_3.png", img:new Image(), frames:4},
 shield:{ file:"Shield.png", img:new Image(), frames:2},    
 dead:{ file:"Dead.png", img:new Image(), frames:3},    
 hurt:{ file:"Hurt.png", img:new Image(), frames:3}    
};    
reloadPlayerSprites();

function reloadPlayerSprites() {
    for (let s in playerSprites){
        playerSprites[s].img.src = getPlayerSpritePath() +
        playerSprites[s].file;
    }
}
    
// =======================    
// SPRITES ENEMY    
// =======================    
const enemySprites={    
 idle:{src:"Sprites/Knight/Enemy/Idle.png",frames:6},    
 walk:{src:"Sprites/Knight/Enemy/Walk.png",frames:10},    
 attack:{src:"Sprites/Knight/Enemy/Attack.png",frames:5},    
 hurt:{src:"Sprites/Knight/Enemy/Hurt.png",frames:4},    
 dead:{src:"Sprites/Knight/Enemy/Dead.png",frames:5}    
};    
for(let s in enemySprites){    
 enemySprites[s].img=new Image();    
 enemySprites[s].img.src=enemySprites[s].src;    
}    
    
// =======================    
// PLAYER    
// =======================    
const player={    
 x:150,y:GROUND_Y-96,w:96,h:96,    
 vx:0,vy:0,speed:4,jumpForce:-12,    
 grounded:true,facing:1,    
 state:"idle",frame:0,frameTime:0,    
 attacking:false,shielding:false,attackToggle:false,    
 maxHp:100,hp:100,damage:15,level:1,exp:0,nextLevelExp:100,
 evolution:1    
};    
    
// üî• AGREGADO ‚Äì CONTROL MUERTE PLAYER        
    
// =======================    
// ENEMY    
// =======================    
const enemy={    
 x:700,y:GROUND_Y-96,w:96,h:96,    
 state:"idle",frame:0,frameTime:0,    
 facing:-1,    
 maxHp:100,hp:100,    
 alive:true,    
 justHit:false,    
 dying:false,    
 remove:false,    
    
 speed:1.2,    
 attackCooldown:0    
};    
    
// =======================    
// RESPAWN ENEMY    
// =======================   

function respawnEnemy(){
    enemy.x = 700;
    enemy.y = GROUND_Y - enemy.h;

    enemy.hp = enemy.maxHp;
    enemy.alive = true;
    enemy.dying = false;
    enemy.remove = false;
    enemy.justHit = false;

    enemy.state = "idle";
    enemy.frame = 0;
    enemy.frameTime = 0;
}
let enemyRespawnTimer = 0;    
const ENEMY_RESPAWN_TIME = 180;    
    
// =======================    
// INPUT    
// =======================    
const keys={};    
window.addEventListener("keydown",e=>{    
 if(keys[e.key])return;    
 keys[e.key]=true;    
    
 if(e.key==="j"&&!player.attacking&&!player.shielding){    
  player.attacking=true;    
  player.attackToggle=!player.attackToggle;    
  player.state=player.attackToggle?"attack1":"attack2";    
  resetAnim(player);    
 }    
 if(e.key==="k"&&!player.attacking&&!player.shielding){    
  player.attacking=true;    
  player.state="attack3";    
  resetAnim(player);    
 }    
 if(e.key==="s"&&!player.attacking){    
  player.shielding=true;    
  player.state="shield";    
  resetAnim(player);    
 }    
 if(e.key==="h"){
    if(!playerDead){
        player.hp -= 10;
        if (player.hp < 0) player.hp = 0;
        console.log("HP:", player.hp);
    }
 }
 if(e.key==="p"){
    gainExp(50);
    console.log("DEBUG: +50 EXP");
 }
});    
window.addEventListener("keyup",e=>{    
 keys[e.key]=false;    
 if(e.key==="s")player.shielding=false;    
});    
const pauseBtn = document.getElementById("pauseBtn");    
pauseBtn.addEventListener("click", ()=>{    
    gamePaused = !gamePaused;    
    pauseBtn.textContent = gamePaused ?    
 "Renaudar" : "‚è∏Ô∏è Pausa";        
});     
const respawnBtn = document.getElementById("respawnBtn");    
respawnBtn.addEventListener("click",    
    ()=>{    
        respawnPlayer();    
        
});    
    
function respawnPlayer() {    
    player.x = 100;    
    player.y = 300;    
    player.hp = player.maxHp;    
    playerDead = false;
    gameOver = false;    
    
    respawnBtn.style.display = "none";    
    gamePaused = false;    
}    
    
    
// =======================    
// UPDATE PLAYER    
// =======================    
function updatePlayer(){    
    
 // üî• AGREGADO ‚Äì PLAYER MUERTO NO SE MUEVE    
 if(playerDead) return;    
    
 if(!player.attacking&&!player.shielding){    
  player.vx=0;    
  if(keys["a"]){player.vx=-player.speed;player.facing=-1;player.state="run";}    
  else if(keys["d"]){player.vx=player.speed;player.facing=1;player.state="run";}    
  else if(player.grounded)player.state="idle";    
    
  if(keys["w"]&&player.grounded){    
   player.vy=player.jumpForce;    
   player.grounded=false;    
   player.state="jump";    
   resetAnim(player);    
  }    
 }    
 player.vy+=GRAVITY;    
 player.x+=player.vx;    
 player.y+=player.vy;    
 if(player.y+player.h>=GROUND_Y){    
  player.y=GROUND_Y-player.h;    
  player.vy=0;    
  player.grounded=true;    
 }    
}    
    
// =======================    
// UPDATE ENEMY IA    
// =======================    
function updateEnemyAI(){
    if (playerDead){
        enemy.state = "idle";
        enemy.attackCooldown = 0;
        return;
    }
    

 if(!enemy.alive || enemy.dying || enemy.remove || playerDead) return;    
    
 const dist = player.x - enemy.x;    
 enemy.facing = dist < 0 ? -1 : 1;    
    
 if(Math.abs(dist) > 90){    
  enemy.x += enemy.speed * enemy.facing;    
  enemy.state = "walk";    
 }else{    
  enemy.state = "attack";    
  if(enemy.attackCooldown <= 0){    
   enemy.attackCooldown = 60;    
   enemyAttack();    
  }    
 }    
    
 if(enemy.attackCooldown > 0) enemy.attackCooldown--;    
}    
    
// =======================    
// ENEMY ATTACK    
// =======================    
function enemyAttack(){    
 if(player.shielding || playerDead) return;
    
 const hitbox={    
  x: enemy.facing===1 ? enemy.x+enemy.w-10 : enemy.x-30,    
  y: enemy.y+30,    
  w:30,h:30    
 };    
    
 const playerBox={x:player.x,y:player.y,w:player.w,h:player.h};    
 if(rectsCollide(hitbox,playerBox)){    
  player.hp -= 10;    
  if(player.hp < 0) player.hp = 0;    
    
  if(player.hp > 0 && !playerDead){    
    player.state = "hurt";    
    resetAnim(player);    
  }
    
 };    
};    
    
// =======================    
// COLLISION    
// =======================    
function rectsCollide(a,b){    
 return a.x<b.x+b.w&&a.x+a.w>b.x&&a.y<b.y+b.h&&a.y+a.h>b.y;    
}    
    
function getAttackHitbox(){    
 if(!player.attacking)return null;    
 const size=40;    
 const offset=player.facing===1?player.w-10:-size+10;    
 return{x:player.x+offset,y:player.y+30,w:size,h:30};    
}    
    
function applyDamage(){    
 if(!enemy.alive || enemy.dying)return;    
 const hitbox=getAttackHitbox();    
 if(!hitbox||enemy.justHit)return;    
 const enemyBox={x:enemy.x,y:enemy.y,w:enemy.w,h:enemy.h};    
 if(rectsCollide(hitbox,enemyBox)){    
  enemy.justHit=true;    
  enemy.hp-=15;    
  enemy.state="hurt";    
  resetAnim(enemy);    
  if(enemy.hp<=0){    
   enemy.hp=0; 
   enemy.alive=false;   
   enemy.dying=true;    
   enemy.state="dead";    
   resetAnim(enemy); 

   enemyRespawnTimer = ENEMY_RESPAWN_TIME;
   
   gainExp(50);
  }    
 }    
}    
    
// =======================    
// ANIMATION    
// =======================    
function resetAnim(e){e.frame=0;e.frameTime=0;}    
    
function animate(e,sprites){    
 e.frameTime++;    
 if(e.frameTime>=6){    
  e.frame++;    
  e.frameTime=0;    
  if(e.frame>=sprites[e.state].frames){    
   e.frame=0;    
    
   if(e===player && e.attacking){    
    e.attacking=false;    
    e.state="idle";    
    enemy.justHit=false;    
   }    
    
   if(e===enemy && e.state==="dead" && enemy.dying){    
    enemy.remove=true;    
    enemy.alive=false;    
   }    
    
   if(e===player && e.state==="hurt"){    
    e.state = "idle";    
   }    
  }    
 }    
    
 // üî• AGREGADO ‚Äì PLAYER DEAD SE QUEDA EN √öLTIMO FRAME    
 if(e===player && playerDead){    
  e.frame = playerSprites.dead.frames - 1;    
 }    
}    
    
// =======================    
// DRAW    
// =======================    
function drawEntity(e,sprites,flip){    
 const s=sprites[e.state];    
 ctx.save();    
 ctx.translate(flip?e.x+e.w:e.x,e.y);    
 ctx.scale(flip?-1:1,1);    
 ctx.drawImage(s.img,e.frame*FRAME_SIZE,0,FRAME_SIZE,FRAME_SIZE,0,0,e.w,e.h);    
 ctx.restore();    
}    
    
function drawHealthBar(e){    
 const r=e.hp/e.maxHp;    
 ctx.fillStyle="red";    
 ctx.fillRect(e.x,e.y-12,e.w,8);    
 ctx.fillStyle="lime";    
 ctx.fillRect(e.x,e.y-12,e.w*r,8);    
}    
    
function draw(){    
    ctx.save();    
    
 ctx.clearRect(0,0,canvas.width,canvas.height);    
 ctx.scale(GAME_SCALE, GAME_SCALE);    
 ctx.fillStyle="#2e7d32";    
 ctx.fillRect(0,GROUND_Y,canvas.width,60);    
    
 drawEntity(player,playerSprites,player.facing===-1);    
    
 if(!enemy.remove){    
  drawEntity(enemy,enemySprites,enemy.facing=== -1);    
  drawHealthBar(enemy);    
 }    
    
 drawHealthBar(player); 
 
 if (gameOver) {
    ctx.fillStyle = "rgba(0,0,0,0.6)";
    ctx.fillRect(0, 0, canvas.width / GAME_SCALE,
        canvas.height / GAME_SCALE);
        
        ctx.fillStyle = "red";
        ctx.font = "48px Arial";
        ctx.textAlign = "center";
        ctx.fillText("GAME OVER", 
        (canvas.width / GAME_SCALE) / 2,
        (canvas.height / GAME_SCALE) / 2);
 }

 drawExpBar();

 if(evolving){
    ctx.fillStyle = "rgba(255,255,255,0.7)";
    ctx.fillRect(0, 0, canvas.width / GAME_SCALE, canvas.height / GAME_SCALE);

    ctx.fillStyle = "black";
    ctx.textAlign = "center";
    ctx.fillText("EVOLUCIONANDO...", 
        (canvas.width/GAME_SCALE)/2,(canvas.height)/2
    );
 }

ctx.restore();
}
 

 
function drawExpBar(){
    ctx.save();
    const barX = 20;
    const barY = 20;
    const barWidth = 200;
    const barHeight = 14;

    const ratio = player.exp / player.nextLevelExp;
    
    ctx.fillStyle = "#333";
    ctx.fillRect(barX, barY, barWidth, barHeight);

    ctx.fillStyle = "#4fc3f7";
    ctx.fillRect(barX, barY, barWidth * ratio, barHeight);

    ctx.strokeStyle = "white";
    ctx.strokeRect(barX, barY, barWidth, barHeight);

    ctx.fillStyle = "white";
    ctx.font = "14px Arial";
    ctx.fillText("Lv " + player.level, barX, barY - 5);

    ctx.restore();
 }  
    
    
// =======================    
// LOOP    
// =======================    
function loop(){ 
    
    if(evolving){
        evolveTimer--;
        if(evolveTimer <= 0){
            finishEvolutionTo2();
        }
        draw();
        requestAnimationFrame(loop);
        return;
    }
    
    if (!playerDead && player.hp <= 0) {
        playerDead = true;
        gameOver = true;
        gamePaused = true;

        player.state = "dead";
        player.vx = 0;
        player.vy = 0;
        resetAnim(player);

        respawnBtn.style.display = "block";
    }
    
    if(gamePaused){    
        draw();    
        requestAnimationFrame(loop);    
        return;    
    }    
 updatePlayer();   
 
 if(enemy.remove){
    if(enemyRespawnTimer <= 0){
        enemyRespawnTimer--;
    }else {
        respawnEnemy();
    }
 }
 updateEnemyAI();    
 animate(player,playerSprites);    
 animate(enemy,enemySprites);    
 applyDamage();    
    
    
 draw();    
 requestAnimationFrame(loop);    
}    
loop();    
</script>  

</body>    

</html>
