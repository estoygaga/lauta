<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>RPG Medieval 2D</title>
<style>
body{
    margin:0;
    background:#111;
    display:flex;
    justify-content:center;
    align-items:center;
    height:100vh;
}
canvas{
    background:linear-gradient(#6ec6ff,#b3e5fc);
    image-rendering:pixelated;
}

#pauseBtn{
    position: absolute;
    top: 15px;
    right: 15px;
    padding: 8px 14px;
    font-size: 16px;
    cursor: pointer;
    z-index: 10;
}
</style>
</head>

<body>
<canvas id="game" width="1000" height="500"></canvas>

<button id="pauseBtn"
style="position: fixed;
top: 10px;
right: 10px;
padding: 10px 18px;
font-size: 16px;
cursor: pointer;
z-index: 10;
">
‚è∏Ô∏è Pausa
</button>

<button id="respawnBtn" style="
position: fixed;
top: 50%;
left: 50%;
transform: translate(-50%,-50%);
padding: 16px 30px;
font-size: 22px;
display: none;
z-index: 20;
cursor: pointer;
">
Respawn
</button>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const GRAVITY = 0.6;
const GROUND_Y = canvas.height - 60;
const FRAME_SIZE = 128;
const GAME_SCALE = 1.5;

let gamePaused = false;

// =======================
// SPRITES PLAYER
// =======================
const playerSprites = {
 idle:{src:"Sprites/Knight/Idle.png",frames:6},
 run:{src:"Sprites/Knight/Run.png",frames:8},
 jump:{src:"Sprites/Knight/Jump.png",frames:10},
 attack1:{src:"Sprites/Knight/Attack_1.png",frames:4},
 attack2:{src:"Sprites/Knight/Attack_2.png",frames:3},
 attack3:{src:"Sprites/Knight/Attack_3.png",frames:4},
 shield:{src:"Sprites/Knight/Shield.png",frames:2},
 dead:{src:"Sprites/Knight/Dead.png",frames:3},
 hurt:{src:"Sprites/Knight/Hurt.png",frames:3}
};
for(let s in playerSprites){
 playerSprites[s].img=new Image();
 playerSprites[s].img.src=playerSprites[s].src;
}

// =======================
// SPRITES ENEMY
// =======================
const enemySprites={
 idle:{src:"Sprites/Knight/Enemy/Idle.png",frames:6},
 walk:{src:"Sprites/Knight/Enemy/Walk.png",frames:10},
 attack:{src:"Sprites/Knight/Enemy/Attack.png",frames:5},
 hurt:{src:"Sprites/Knight/Enemy/Hurt.png",frames:4},
 dead:{src:"Sprites/Knight/Enemy/Dead.png",frames:5}
};
for(let s in enemySprites){
 enemySprites[s].img=new Image();
 enemySprites[s].img.src=enemySprites[s].src;
}

// =======================
// PLAYER
// =======================
const player={
 x:150,y:GROUND_Y-96,w:96,h:96,
 vx:0,vy:0,speed:4,jumpForce:-12,
 grounded:true,facing:1,
 state:"idle",frame:0,frameTime:0,
 attacking:false,shielding:false,attackToggle:false,
 maxHp:100,hp:100
};

// üî• AGREGADO ‚Äì CONTROL MUERTE PLAYER
let playerDead = false;

let showGameOver = false;

// =======================
// ENEMY
// =======================
const enemy={
 x:700,y:GROUND_Y-96,w:96,h:96,
 state:"idle",frame:0,frameTime:0,
 facing:-1,
 maxHp:100,hp:100,
 alive:true,
 justHit:false,
 dying:false,
 remove:false,

 speed:1.2,
 attackCooldown:0
};

// =======================
// RESPAWN ENEMY
// =======================
let enemyRespawnTimer = 0;
const ENEMY_RESPAWN_TIME = 180;

// =======================
// INPUT
// =======================
const keys={};
window.addEventListener("keydown",e=>{
 if(keys[e.key])return;
 keys[e.key]=true;

 if(e.key==="j"&&!player.attacking&&!player.shielding){
  player.attacking=true;
  player.attackToggle=!player.attackToggle;
  player.state=player.attackToggle?"attack1":"attack2";
  resetAnim(player);
 }
 if(e.key==="k"&&!player.attacking&&!player.shielding){
  player.attacking=true;
  player.state="attack3";
  resetAnim(player);
 }
 if(e.key==="s"&&!player.attacking){
  player.shielding=true;
  player.state="shield";
  resetAnim(player);
 }
});
window.addEventListener("keyup",e=>{
 keys[e.key]=false;
 if(e.key==="s")player.shielding=false;
});
const pauseBtn = document.getElementById("pauseBtn");
pauseBtn.addEventListener("click", ()=>{
    gamePaused = !gamePaused;
    pauseBtn.textContent = gamePaused ?
 "Renaudar" : "‚è∏Ô∏è Pausa";    
}); 
const respawnBtn = document.getElementById("respawnBtn");
respawnBtn.addEventListener("click",
    ()=>{
        respawnPlayer();
    
});

function respawnPlayer() {
    player.x = 100;
    player.y = 300;
    player.health = player.maxHealth;
    player.dead = false;

    respawnBtn.style.display = "none";
    gamePaused = false;
}


// =======================
// UPDATE PLAYER
// =======================
function updatePlayer(){

 // üî• AGREGADO ‚Äì PLAYER MUERTO NO SE MUEVE
 if(playerDead) return;

 if(!player.attacking&&!player.shielding){
  player.vx=0;
  if(keys["a"]){player.vx=-player.speed;player.facing=-1;player.state="run";}
  else if(keys["d"]){player.vx=player.speed;player.facing=1;player.state="run";}
  else if(player.grounded)player.state="idle";

  if(keys["w"]&&player.grounded){
   player.vy=player.jumpForce;
   player.grounded=false;
   player.state="jump";
   resetAnim(player);
  }
 }
 player.vy+=GRAVITY;
 player.x+=player.vx;
 player.y+=player.vy;
 if(player.y+player.h>=GROUND_Y){
  player.y=GROUND_Y-player.h;
  player.vy=0;
  player.grounded=true;
 }
}

// =======================
// UPDATE ENEMY IA
// =======================
function updateEnemyAI(){
 if(!enemy.alive || enemy.dying || enemy.remove || playerDead) return;

 const dist = player.x - enemy.x;
 enemy.facing = dist < 0 ? -1 : 1;

 if(Math.abs(dist) > 90){
  enemy.x += enemy.speed * enemy.facing;
  enemy.state = "walk";
 }else{
  enemy.state = "attack";
  if(enemy.attackCooldown <= 0){
   enemy.attackCooldown = 60;
   enemyAttack();
  }
 }

 if(enemy.attackCooldown > 0) enemy.attackCooldown--;
}

// =======================
// ENEMY ATTACK
// =======================
function enemyAttack(){
 if(player.shielding || playerDead) return;

 const hitbox={
  x: enemy.facing===1 ? enemy.x+enemy.w-10 : enemy.x-30,
  y: enemy.y+30,
  w:30,h:30
 };

 const playerBox={x:player.x,y:player.y,w:player.w,h:player.h};
 if(rectsCollide(hitbox,playerBox)){
  player.hp -= 10;
  if(player.hp < 0) player.hp = 0;

  if(player.hp > 0){
    player.state = "hurt";
    resetAnim(player);
  }
 }
}

// =======================
// COLLISION
// =======================
function rectsCollide(a,b){
 return a.x<b.x+b.w&&a.x+a.w>b.x&&a.y<b.y+b.h&&a.y+a.h>b.y;
}

function getAttackHitbox(){
 if(!player.attacking)return null;
 const size=40;
 const offset=player.facing===1?player.w-10:-size+10;
 return{x:player.x+offset,y:player.y+30,w:size,h:30};
}

function applyDamage(){
 if(!enemy.alive || enemy.dying)return;
 const hitbox=getAttackHitbox();
 if(!hitbox||enemy.justHit)return;
 const enemyBox={x:enemy.x,y:enemy.y,w:enemy.w,h:enemy.h};
 if(rectsCollide(hitbox,enemyBox)){
  enemy.justHit=true;
  enemy.hp-=15;
  enemy.state="hurt";
  resetAnim(enemy);
  if(enemy.hp<=0){
   enemy.hp=0;
   enemy.dying=true;
   enemy.state="dead";
   resetAnim(enemy);
  }
 }
}

// =======================
// ANIMATION
// =======================
function resetAnim(e){e.frame=0;e.frameTime=0;}

function animate(e,sprites){
 e.frameTime++;
 if(e.frameTime>=6){
  e.frame++;
  e.frameTime=0;
  if(e.frame>=sprites[e.state].frames){
   e.frame=0;

   if(e===player && e.attacking){
    e.attacking=false;
    e.state="idle";
    enemy.justHit=false;
   }

   if(e===enemy && e.state==="dead" && enemy.dying){
    enemy.remove=true;
    enemy.alive=false;
   }

   if(e===player && e.state==="hurt"){
    e.state = "idle";
   }
  }
 }

 // üî• AGREGADO ‚Äì PLAYER DEAD SE QUEDA EN √öLTIMO FRAME
 if(e===player && playerDead){
  e.frame = playerSprites.dead.frames - 1;
 }
}

// =======================
// DRAW
// =======================
function drawEntity(e,sprites,flip){
 const s=sprites[e.state];
 ctx.save();
 ctx.translate(flip?e.x+e.w:e.x,e.y);
 ctx.scale(flip?-1:1,1);
 ctx.drawImage(s.img,e.frame*FRAME_SIZE,0,FRAME_SIZE,FRAME_SIZE,0,0,e.w,e.h);
 ctx.restore();
}

function drawHealthBar(e){
 const r=e.hp/e.maxHp;
 ctx.fillStyle="red";
 ctx.fillRect(e.x,e.y-12,e.w,8);
 ctx.fillStyle="lime";
 ctx.fillRect(e.x,e.y-12,e.w*r,8);
}

function draw(){
 ctx.clearRect(0,0,canvas.width,canvas.height);
 ctx.fillStyle="#2e7d32";
 ctx.fillRect(0,GROUND_Y,canvas.width,60);

 drawEntity(player,playerSprites,player.facing===-1);

 if(!enemy.remove){
  drawEntity(enemy,enemySprites,enemy.facing=== -1);
  drawHealthBar(enemy);
 }

 drawHealthBar(player);
}

// =======================
// LOOP
// =======================
function loop(){

    if(gamePaused){
        draw();
        requestAnimationFrame(loop);
        return;
    }
 updatePlayer();
 updateEnemyAI();
 animate(player,playerSprites);
 animate(enemy,enemySprites);
 applyDamage();

 // üî• AGREGADO ‚Äì DETECTAR MUERTE PLAYER
 if(!playerDead && player.hp <= 0){
  playerDead = true;
  player.state = "dead";
  player.vx = 0;
  player.vy = 0;
  resetAnim(player);
 }

 draw();
 requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
